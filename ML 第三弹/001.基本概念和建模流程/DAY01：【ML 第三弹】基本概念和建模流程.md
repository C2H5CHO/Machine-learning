# 1、机器学习基本概念
## 1.1 模型训练
- **模型评估指标**：用于评估模型实际效果的数值型指标，如准确率
- **模型参数**：对模型最终输出结果有影响的模型关键指标，如自变量加权求和汇总过程中的权重
- **模型训练**：指通过不断的数据输入、模型参数得到有效调整的过程，此处模型参数的有效调整指的是调整之后能够提升模型表现
## 1.2 经典统计分析方法
&emsp;&emsp;线性回归模型是诞生于是统计学领域的一类模型，同时也是整个线性类模型大类的基础模型，是一类非常重要的统计学模型。

&emsp;&emsp;在经典统计学领域，线性回归模型拥有坚实的数学理论基础作为支撑，曾在很长一段时间内都是数理统计分析建模最通用的模型之一。值得一提的是，使用传统的统计学方法构建线性回归模型其实并不简单，如果要构建一个统计学意义的线性回归模型，则至少需要掌握随机变量的基本分布、变量相关性与独立性、方差分析等基本统计学知识，才能够上手构建线性回归模型。

&emsp;&emsp;在机器学习领域，由于机器学习的基本建模思路和流程和经典统计分析有很大区别，在构建线性回归模型时流程较为简单，外加线性回归模型本身可解释性较强，因此可以作为入门的第一个算法来学习。

&emsp;&emsp;从机器学习的角度出发，所谓线性回归，指的是自变量（特征）加权求和汇总求得因变量（标签）的过程。

> 例如，$y = w_1x_1+w_2x_2$的计算过程，就是一个简单的线性回归。

## 1.3 数据集
### 1.3.1 数据与数据集
&emsp;&emsp;所谓数据，特指能够描绘某件事物的属性或者运行状态的数值，并且一个数据集由多条数据构成。

> 例如，鸢尾花数据，就是描述鸢尾花一般属性的数据集。

```python
import numpy as np
import pandas as pd

df_iris = pd.read_csv('iris.csv')
print(df_iris.head())
```

- 运行结果：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ba98f7506b2a4363a8c3c4671900124b.png)

- 数据集概述：
1. 文件名为 iris.csv，包含了鸢尾花的相关信息
2. 文件包含了150条鸢尾花的数据
3. 数据集包含了鸢尾花的萼片长度（$sepal\_length$）、萼片宽度（$sepal\_width$）、花瓣长度（$petal\_length$）、花瓣宽度（$petal\_width$）以及鸢尾花的种类（$species$）

### 1.3.2 特征与标签
&emsp;&emsp;鸢尾花数据集中的每一列是所有描述对象的一项共同指标。其中，前四列分别描述了鸢尾花的四项生物学性状，而最后一列则描述了每一朵花所属类别。

&emsp;&emsp;如果上述表格的记录目的是通过记录鸢尾花的四个维度的不同属性的取值最终判别鸢尾花属于哪一类，则该数据集中的前四列也被称为数据集的**特征**（$features$），而最后一列被称为数据集的**标签**（$labels$）。

&emsp;&emsp;据此，在实际建模过程中，当需要利用模型进行预测时，也是通过输入模型一些样本的特征（一些鸢尾花的四个特征取值），让模型进行每个样本的标签判别（判别每一朵花应该属于哪一类）。

&emsp;&emsp;但是，标签和特征，只是依据模型预测目标进行的、围绕数据集不同列进行的划分方式，如果模型的预测目标发生变化，则数据集的特征和标签也会发生变化。

> 例如，如果围绕鸢尾花数据集我们最终是进行每一朵花的花瓣宽（$petal width$）的预测，则上述数据集中1、2、3、5列就变成了特征，第4列变成了标签。

&emsp;&emsp;因此，特征和标签本质上都是==人工设置==的。一般来说，==标签列放在最后一列==。

> 注意：数据集中的列也被称为字段，鸢尾花数据集中总共有5列，也就总共有5个字段。

### 1.3.3 连续变量和离散变量
&emsp;&emsp;随机变量有离散变量和连续变量之分。

&emsp;&emsp;连续变量，指的是随机变量能够取得连续数值。

> 例如，随机变量表示距离或者长度测算结果时，该变量就是连续性变量。

&emsp;&emsp;离散变量，指的是随机变量只允许取得离散的整数。

> 例如，随机变量用0/1表示性别。

> 注意：在传统统计分析领域，对于离散型变量，可细分为名义型变量和顺序性变量。
> 
> `名义变量`，指的是随机变量取得不同离散值时，取值大小本身没有数值意义，只有指代意义。例如，用0/1代表男女，则该变量没有1>0的数值意义。
> 
> `顺序变量`，则有大小方面的数值意义。例如，使用0/1/2代表高中/本科/研究生学历，则可用2>1>0来表示学习的高低之分。

## 1.4 模型类型
&emsp;&emsp;离散型变量和连续性变量在数理特征上有很大的区别。因此，对于预测类的机器学习建模来说，标签这一预测指标是连续型变量还是离散型变量，会对模型预测过程造成很大影响。

&emsp;&emsp;据此，围绕离散型标签进行建模预测，则称任务为**分类预测任务**，该模型为解决分类任务的**分类**（$classification$）**模型**，而如果是围绕连续型标签进行建模预测，则称该任务为**回归预测任务**，该模型为解决回归问题的**回归**（$regression$）**模型**。

```python
import numpy as np
import pandas as pd

df_abalone = pd.read_csv('abalone.txt', sep='\t', header=None)
print(df_abalone.head())
```

- 运行结果：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/af7fdf2eedaf40559c35aa6d0433821d.png)

- 数据集概述：

|Name|Description|      
|:--:|:--:|      
|Gender|性别，1为Male、-1为Femel、0为infant|      
|Length|最长外壳尺寸|	      
|Diameter|垂直于长度的直径|	      
|Height|带壳肉的高度|    
|Whole weight|整体重量|
|Shucked weight|脱壳重量|
|Viscera weight|内脏的重量|
|Shell weight|壳的重量|
|Rings|（年轮）年龄|

```python
print(df_abalone.columns)
print('--'*50)
df_abalone.columns = ['Gender', 'Length', 'Diameter', 'Height', 'Whole weight', 'Shucked weight', 'Viscera weight', 'Shell weight', 'Rings']
print(df_abalone.head())
df_abalone.to_csv('abalone.csv', index=False)
```

- 运行结果：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a8ea9daef544f0c8868e0c2b7915125.png)

&emsp;&emsp;对于$abalone$数据集来说，$Rings$是标签，围绕$Rings$的预测任务是连续型变量的预测任务，因此是回归类问题。

# 2、线性回归模型建模准备与模型训练
## 2.1 建模准备
### 2.1.1 数据准备
&emsp;&emsp;线性回归是属于回归类模型，是针对连续型变量进行数值预测的模型，因此选用$abalone$数据集进行建模。

|Whole weight|Rings|      
|:--:|:--:|   
|1|2|      
|3|4|	      

### 2.1.2 模型准备
&emsp;&emsp;上述数据集是极端简化后的数据集，只有一个连续型特征和连续型标签，并且只包含两条数据。围绕只包含一个特征的数据所构建的线性回归模型，也被称为简单线性回归。简单线性回归的模型表达式为：$$y = wx + b$$

其中$x$表示自变量，即数据集特征；$w$表示自变量系数，代表每次计算都需要相乘的某个数值；$b$表示截距项，代表每次计算都需要相加的某个数值；而$y$表示因变量，即模型输出结果。

> 除了简单线性回归外，线性回归主要还包括多元线性回归和多项式回归两类。      
> 
> `多元线性回归`用于解决包含多个特征的回归类问题，模型基本表达式为：$$y = w_1x_1+w_2x+...+w_nx_n+b$$
其中$x_{1...n}$表示$n$个自变量，对应数据集的$n$个特征，$w_{1...n}$表示$n$个自变量的系数，$b$表示截距。简单线性回归也是多元线性回归的一个特例。
> 
> `多项式回归`则是在多元线性回归基础上，允许自变量最高次项超过1次。例如，$$y = w_1x_1^2+w_2x_2+b$$

## 2.2 模型训练
### 2.2.1 参数调整
#### （1）模型训练与模型参数调整
&emsp;&emsp;**模型训练**，指的是对模型参数进行有效调整。模型参数是影响模型输出的关键变量。

|数据特征|参数组|模型输出|数据标签|      
|:--:|:--:|:--:|:--:|   
|Whole weight(x)|$(w,b)$|$\hat y$|Rings(y)|    
|1|(1, -1)|0|2|
|3|(1, -1)|2|4|
|1|(1, 0)|1|2|
|3|(1, 0)|3|4|

> 本例，模型包含两个参数$w_1$和$b$，当参数取得不同值时，模型将输出完全不同的结果。而不同组的参数取值似乎也有“好坏之分”。当参数组取值为(1,0)时的模型输出结果，要比参数组取值为(1,-1)时输出结果更加贴近真实值。这就说明第二组参数要优于第一组参数。而“机器”在“学习”的过程，或者说模型训练过程，就是需要找到一组最优参数。

#### （2）模型评估指标和损失函数
- 模型评估指标

&emsp;&emsp;模型评估指标，指的是评估模型输出结果“好与坏”的标量计算结果，其最终结果一般由模型预测值$\hat y$和真实值$y$共同计算得出，而对于回归类问题，最重要的模型评估指标就是**SSE——残差平方和**。

&emsp;&emsp;**残差平方和**，指的是模型预测值$\hat y$和真实值$y$之间的差值的平方和。计算结果表示预测值和真实值之间的差距，结果越小表示二者差距越小，模型效果越好。SSE基本计算公式为：$$SSE = \sum_{i=1}^{n}(\hat y_i-y_i)^2$$
其中n为样本数量。对应的，上述两组不同参数取值对应的模型残差平方和计算结果依次为：
$$SSE_{(1,-1)} = (0-2)^2+(2-4)^2 = 8$$
$$SSE_{(1,0)} = (1-2)^2+(3-4)^2 = 2$$
由此可见，第二组参数对应模型效果更好。据此，就找到了能够量化评估模型效果好坏的指标。

- 损失函数

&emsp;&emsp;有了模型评估指标之后，我们还需要将评估结果有效的反馈给模型，这时就需要引入另一个至关重要的概念：**损失函数**（Loss Function）。

&emsp;&emsp;模型评估指标是真实值和预测值的计算，模型的损失函数都是关于模型参数的函数。

&emsp;&emsp;损失函数本质上一个衡量模型预测结果和真实结果之间的差异的计算过程，例如，在SSE中如果带入模型参数，则就能构成一个SSE损失函数，基本计算过程如下：

|数据特征|参数组|模型输出|数据标签|      
|:--:|:--:|:--:|:--:|   
|Whole weight(x)|$(w,b)$|$\hat y$|Rings(y)|    
|1|(w, b)|w+b|2|
|3|(w, b)|3w+b|4|

$$SSELoss(w, b) = (y_1 - ŷ_1)^2 + (y_2 - ŷ_2)^2 = (2 - w - b)^2 + (4 - 3w - b)^2$$

&emsp;&emsp;由此可见，SSE和SSELoss的计算过程类似，那为何要区别损失函数和模型评估指标呢？
1. 对于很多模型（尤其是分类模型）来说，模型评估指标和模型损失函数的计算过程并不一致。例如，准确率就很难转化为一个以参数为变量的函数表达式
2. 模型评估指标和损失函数构建的目标不同，模型评估指标的计算目标是给模型性能一个标量计算结果，而损失函数的构建则是为了找到一组最优的参数结果

> 注意：除了SSE以外，常用的回归类问题的评估指标还有MSE（均方误差）和RMSE（均方根误差）：
> $$MSE = \frac{1}{n}SSE = \frac{1}{n}\sum_{i=1}^{n}(\hat y_i-y_i)^2$$
> $$RMSE = \sqrt{MSE} = \sqrt{\frac{1}{n}\sum_{i=1}^{n}(\hat y_i-y_i)^2}$$
> 对应的，MSE和RMSE也有相对的损失函数。

&emsp;&emsp;损失函数的核心作用：==搭建参数求解的桥梁，构建一个协助模型求解参数的方程==，并通过损失函数的构建，将求解模型最优参数的问题转化为求解损失函数最小值的问题。

### 2.2.2 求解损失函数
#### （1）函数的可视化
&emsp;&emsp;为了更好的讨论损失函数（SSELoss）求最小值的过程，对于上述二元损失函数来说，可以将其展示在三维空间中，三维空间坐标分别为：$w、b、SSELoss$。

$$SSELoss(w, b) = (y_1 - ŷ_1)^2 + (y_2 - ŷ_2)^2 = (2 - w - b)^2 + (4 - 3w - b)^2$$

```python
import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.arange(-1,3,0.05)
y = np.arange(-1,3,0.05)
w, b = np.meshgrid(x, y)
SSE = (2 - w - b) ** 2 + (4 - 3 * w - b) ** 2

ax = plt.axes(projection='3d')
ax.plot_surface(w, b, SSE, cmap='rainbow')
ax.contour(w, b, SSE, zdir='z', offset=0, cmap="rainbow")  #生成z方向投影，投到x-y平面
plt.xlabel('w')
plt.ylabel('b')
plt.show()
```

- 运行结果：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ef3aaedda5b544be862f543550adcd02.png)
#### （2）函数的凹凸性
&emsp;&emsp;凸函数的一般定义：对于任意一个函数，如果函数f(x)上存在任意两个点，$x_1, x_2$，且      
$$ \frac{f(x_1) + f(x_2)}{2} >= f(\frac{x_1 + x_2}{2}) $$    
就判定这个函数是凸函数。而对于一个凸函数来说，全域最小值明显存在。

#### （3）最小二乘法
&emsp;&emsp;最小二乘法求解凸函数最小值的基本出发点：==通过寻找损失函数导函数==（或者偏导函数联立的方程组）==为0的点==，来求解损失函数的最小值。

> 注意：关于驻点、临界点、边界点和拐点的概念讨论：      
> 
> 从更严格的意义上来说，凸函数的最小值点是根据边界点和驻点（导数为0的点）决定，如果没有边界点且没有驻点，则函数没有最小值（例如$y=x$）；如果存在边界点，但没有驻点，则边界点的一侧就是最小值点；如果存在驻点（且左右两边单调性相反），则驻点就是最小值点。
> 
> 驻点也可以说是临界点，但不是拐点，拐点特指左右两边函数凹凸性发生变化的点。

&emsp;&emsp;根据上述理论，使用最小二乘法求解SSELoss，即：
$$SSELoss=(2 - w - b)^2 + (4 - 3w - b)^2$$
本质上就是在找到能够令损失函数偏导数取值都为零的一组$(w,b)$。SSELoss的两个偏导数计算过程如下：

$$
\begin{align} \frac{\partial{SSELoss}}{\partial{(w)}}  
& = 2(2-w-b)*(-1) + 2(4-3w-b)*(-3)\\
& = 20w+8b-28 \\
& = 0  \end{align}
$$

$$
\begin{align} \frac{\partial{SSELoss}}{\partial{(b)}}  
& = 2(2-w-b)*(-1) + 2(4-3w-b)*(-1)\\
& = 8w+4b-12 \\ 
& = 0 \end{align}
$$

最终可得，损失函数最小值点为(1,1)，即当$w=1,b=1$时模型损失函数计算结果最小、模型SSE取值最小、模型效果最好，此时SSE=0，线性回归模型计算结果为：
$$ y = x + 1 $$

对比此前参数计算结果：

|数据特征|参数组|模型输出|数据标签|      
|:--:|:--:|:--:|:--:|   
|Whole weight(x)|$(w,b)$|$\hat y$|Rings(y)|    
|1|(1, -1)|0|2|
|3|(1, -1)|2|4|
|1|(1, 0)|1|2|
|3|(1, 0)|3|4|

至此，就完成了一个机器学习建模的完整流程。

# 3、机器学习建模流程
## 3.1 提出基本模型
> 例如，本节中尝试利用简单线性回归去捕捉一个简单数据集中的基本数据规律，这里的$y=wx+b$就是提出的基本模型。值得注意的是，在提出模型时，往往会预设好一些影响模型结构或者实际判别性能的参数，如简单线性回归中的$w$和$b$。

## 3.2 确定损失函数
&emsp;&emsp;围绕建模的目标构建评估指标，并且围绕评估指标设置损失函数。

> 例如，本节中模型评估指标和损失函数的建模流程相同。值得注意的是，损失函数不是模型，而是==模型参数所组成的一个函数==。

## 3.3 根据损失函数性质，选择优化方法
&emsp;&emsp;损失函数既承载了优化的目标（让预测值和真实值尽可能接近），同时也是包含了模型参数的函数，当围绕目标函数求解最小值时，也就完成了模型参数的求解。这个过程本质上就是一个数学的最优化过程，求解目标函数最小值本质上也就是一个最优化问题，而要解决这个问题，就需要灵活适用一些最优化方法。当然，在具体的最优化方法的选择上，函数本身的性质是重要影响因素，也就是说，不同类型、不同性质的函数会影响优化方法的选择。在简单线性回归中，由于目标函数是凸函数，根据凸函数性质，选取了最小二乘法作为该损失函数的优化算法。

## 3.4 利用优化算法，求解损失函数
&emsp;&emsp;在确定优化方法之后，就能够借助优化方法对损失函数进行求解，当然大多数情况下都是求解损失函数的最小值。而伴随损失函数最小值点确定，也就找到了一组对应的损失函数自变量的取值，而改组自变量的取值也就是模型的最佳参数。

-------
`微语录：向着月亮出发，即使不能到达，也能站在群星之中。`
